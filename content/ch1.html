<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" href="../src/favicon.png" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Julius+Sans+One&family=Montserrat:ital,wght@0,400;0,500;1,400&family=Srisakdi:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles/main.css" />
    <title>Java 1Z0-819 Prep</title>
</head>

<body>
    <div class="container">
        <aside class="sidebar">
            <button class="sidebar__btn">
                <svg class="sidebar__icon">
                    <use xlink:href="../src/sprite.svg#icon-chevron-right" class="sidebar__icon-1"></use>
                    <use xlink:href="../src/sprite.svg#icon-chevron-left" class="sidebar__icon-2"></use>
                </svg>
            </button>
            <ul class="sidebar__links">
                <li><a href="#goals" class="sidebar__link">Topic goals</a></li>
                <li><a href="#item-1" class="sidebar__link">1. understand primitive types in Java</a></li>
                <li><a href="#item-2" class="sidebar__link">2. understand wrapper classes in Java</a></li>
                <li><a href="#item-3" class="sidebar__link">3. understand auto-boxing &amp; auto-unboxing</a></li>
                <li><a href="#item-4" class="sidebar__link">4. understand type promotion and casting</a></li>
                <li><a href="#item-5" class="sidebar__link">5. learn about operators and their precedence</a></li>
                <li><a href="#item-6" class="sidebar__link">6. learn about var (local variable type inference) &amp;
                        lambda parameters</a></li>
                <li><a href="#item-7" class="sidebar__link">Summary of Topic 1</a></li>
            </ul>
        </aside>
        <button class="backToTop">
            <svg class="backToTop__icon">
                <use xlink:href="../src/sprite.svg#icon-arrow-up"></use>
            </svg>
        </button>
        <button class="theme">
            <svg class="theme__icon">
                <use class="theme__icon--light" xlink:href="../src/sprite.svg#icon-sun"></use>
                <use class="theme__icon--dark" xlink:href="../src/sprite.svg#icon-moon"></use>
            </svg>
        </button>
        <div class="size-control">
            <button class="size-control__icon size-control__icon-plus">
                <svg>
                    <use xlink:href="../src/sprite.svg#icon-plus"></use>
                </svg>
            </button>
            <button class="size-control__icon size-control__icon-minus">
                <svg>
                    <use xlink:href="../src/sprite.svg#icon-minus"></use>
                </svg>
            </button>
        </div>
        <header class="header">
            <nav class="nav">
                <button class="nav__icon">
                    <svg class="nav__icon__svg">
                        <use xlink:href="../src/sprite.svg#icon-more"></use>
                        <use xlink:href="../src/sprite.svg#icon-x"></use>
                    </svg>
                </button>
                <ul class="nav__links">
                    <li class="nav__item">
                        <a href="../index.html" class="nav__link">Content</a>
                    </li>
                    <li class="nav__item">
                        <a href="../overview.html" class="nav__link">Overview</a>
                    </li>
                    <li class="nav__item">
                        <a href="../keywords.html" class="nav__link">Keywords</a>
                    </li>
                    <li class="nav__item">
                        <a href="../contact.html" class="nav__link">Contact</a>
                    </li>
                </ul>
            </nav>
        </header>
        <main class="topic">
            <h1 class="topic__title">Topic 1: Java Data Types</h1>
            <h2 class="topic__subtitle" id="goals">Topic goals</h2>
            <ol class="topic__goals">
                <li class="topic__goals__item">understand primitive types in Java</li>
                <li class="topic__goals__item">understand wrapper classes in Java</li>
                <li class="topic__goals__item">understand auto-boxing &amp; auto-unboxing</li>
                <li class="topic__goals__item">understand type promotion and casting</li>
                <li class="topic__goals__item">learn about operators and their precedence</li>
                <li class="topic__goals__item">learn about var (local variable type inference) &amp; lambda parameters
                </li>
            </ol>

            <section class="topic__section">
                <h2 class="topic__section__title" id="item-1">1. understand primitive types in Java</h2>
                <h3 class="topic__section__subtitle">The 8 types of primitive data</h3>
                <table class="table">
                    <thead>
                        <tr class="table__row">
                            <th>Types</th>
                            <th>Size in bits</th>
                            <th>Value range</th>
                            <th>Optional suffix</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="table__row">
                            <td>boolean</td>
                            <td>n/a</td>
                            <td>false, true</td>
                            <td>n/a</td>
                        </tr>
                        <tr class="table__row">
                            <td>byte</td>
                            <td>8</td>
                            <td>from -128 to 127</td>
                            <td>n/a</td>
                        </tr>
                        <tr class="table__row">
                            <td>char</td>
                            <td>16</td>
                            <td>from 0 to 2^16-1</td>
                            <td>n/a</td>
                        </tr>
                        <tr class="table__row">
                            <td>short</td>
                            <td>16</td>
                            <td>from 2^15 to 2^15-1</td>
                            <td>n/a</td>
                        </tr>
                        <tr class="table__row">
                            <td>int</td>
                            <td>32</td>
                            <td>from 2^(-31) to 2^31-1</td>
                            <td>n/a</td>
                        </tr>
                        <tr class="table__row">
                            <td>long</td>
                            <td>64</td>
                            <td>from 2^(-63) to 2^63-1</td>
                            <td>l or L</td>
                        </tr>
                        <tr class="table__row">
                            <td>float</td>
                            <td>32</td>
                            <td>from 2^(-149) to (2-2^(-23))*2^127</td>
                            <td>f or F</td>
                        </tr>
                        <tr class="table__row">
                            <td>double</td>
                            <td>64</td>
                            <td>from 2^(-1074) to (2-2^(-52))*2^1023</td>
                            <td>n/a</td>
                        </tr>
                    </tbody>
                </table>
                <p>Let's now look at some examples of declaring and initializing variables of the 8 primitive types of
                    data below (note that in Java, what comes after <span class="specialName">//</span> is considered as
                    comments, i.e. things we add as comments in a program that will not be compiled):</p>
                <code class="preformat">
                    boolean var1 = true;<br />
                    byte var2 = 1__0; <span class="comment">// 1__0 is simply 10 since underscores in between
                            numbers can be added for
                            readability reasons</span><br />
                    char var3 = 0;<br />
                    short __var4 = 0; <span class="comment">// underscores are allowed in variable names</span><br />
                    int var5 = 0123; <span class="comment">// var5 will be assigned 83, as 0-prefixed numbers are
                            considered octal</span><br />
                    long var6$$$ = 0L; <span class="comment">// $ can appear anywhere except at the beginning of a
                            variable name</span><br />
                    float var7 = 0.0f;<br />
                    double var8 = 0.0;
                    </code>
                <p>Next, let's also look at some <span class="emphasis">invalid</span> examples below:</p>
                <code class="preformat">
                    boolean 9var = false; <span class="comment">// DNC (does not compile) as variable name cannot
                            start with a number</span><br />
                    byte var10 = 128; <span class="comment">// DNC as 128 exceeds range of byte (128 is reckoned by
                            compiler as int)</span><br />
                    char _ = 0; <span class="comment">// DNC as a single underscore cannot be used as a variable
                            name</span><br />
                    short var12 = _0; <span class="comment">// DNC as an underscore can't be at the beginning of a
                            number</span><br />
                    int var13 = 0.0; <span class="comment">// DNC as 0.0 is reckoned as a double value which is
                            bigger than an int</span><br />
                    long var14 = 0.0; <span class="comment">// DNC, reason similar to above</span><br />
                    float var15 = 0.0; <span class="comment">// DNC, reason similar to above (f suffix has to be
                            explicitly added to mean
                            float)</span><br />
                    double var16 = false; <span class="comment">// DNC as boolean values can not be assigned to
                            other primitive types</span>
                </code>

                <h3 class="topic__section__subtitle">Basic operations on primitive data</h3>
                <p>The basic arithmetic operations <span class="emphasis">+</span> (addition), <span class="emphasis">-</span> (subtraction), <span class="emphasis">*</span> (multiplication), <span class="emphasis">/</span> (division) and <span class="emphasis">%</span> (modulus) can be
                    applied to all these types <span class="emphasis">except for boolean</span>.</p>
                <p>Note that these operators have different orders of precedence. In specific, *, /, % will be carried
                    out before +, - as one would expect.</p>
                <p>More on operators and their precedence later.</p>
            </section>
            <section class="topic__section">
                <h2 class="topic__section__title" id="item-2">2. understand wrapper classes in Java</h2>
                <h3 class="topic__section__subtitle">Wrapper classes in a nutshell</h3>
                <p>Basically, a wrapper class is an <span class="keyword">Object</span> that is used to contain a
                    particular primitive type.</p>
                <p>For all primitive types except int and char, their corresponding wrapper classes are represented by
                    their names with a capitalized first letter.</p>
                <p>For example, the wrapper class for boolean is <span class="emphasis">Boolean</span>, and for short,
                    <span class="emphasis">Short</span>. This is possible because Java is case-sensitive.
                </p>
                <p>For the primitive types int and char, their wrapper classes are <span class="emphasis">Integer</span>
                    and <span class="emphasis">Character</span> respectively.</p>
                <p>As wrapper classes are objects, they have methods associated with them which one can use for
                    different behaviours.</p>
                <p>In particular, all these wrapper classes have methods to transform their values back to their
                    primitive counterparts:</p>
                <ul class="list">
                    <li>Boolean: booleanValue()</li>
                    <li>Byte: byteValue()</li>
                    <li>Character: charValue()</li>
                    <li>Short: shortValue()</li>
                    <li>Integer: intValue()</li>
                    <li>Long: longValue()</li>
                    <li>Float: floatValue()</li>
                    <li>Double: doubleValue()</li>
                </ul>
                <p>As an example, we may create a Boolean variable and assign to it a boolean value, and then get back
                    the boolean value from the Boolean variable by using the booleanValue() function:</p>
                <code class="preformat">
                    Boolean booObj = true;<br />
                    boolean booValue = booObj.booleanValue();
                </code>
                <p>But as we will see very soon, such explicit transformation from a wrapper class to its primitive type
                    (and vice versa) is not necessary as this will be done automatically under the hood. Therefore, the
                    following will work directly:</p>
                <code class="preformat">
                    Boolean booObj = true;<br />
                    boolean booValue = booObj;
                </code>
                <p>Such automatic conversion from a wrapper class to a primitive type is usually referred to as <span class="keyword">unboxing</span>. In fact, when we
                    assign to the wrapper class object <span class="specialName">booObj</span> the primitive value <span class="emphasis">true</span>,
                    automatic conversion from the primitive to the wrapper class has already been performed for us (by
                    using a function <span class="specialName">.valueOf()</span> of the wrapper class). The
                    automatic
                    conversion
                    from a primitive type to a wrapper class is known as <span class="keyword">autoboxing</span>.</p>
                <p>As an example, when we wrote the assignment <span class="formula">Boolean booObj = true;</span> in
                    the above, the Java compiler actually used <span class="formula">Boolean booObj = <span class="emphasis">Boolean.valueOf(</span>true<span class="emphasis">)</span></span> to
                    convert the primitive boolean value true to a Boolean value first before the assignment under the
                    hood.</p>
            </section>
            <section class="topic__section">
                <h2 class="topic__section__title" id="item-3">3. understand auto-boxing &amp; auto-unboxing</h2>
                <p>As described above, both auto-boxing and auto-unboxing are automatic processes that the Java compiler
                    does for you.</p>
                <p>Now, what are these processes exactly? The following <a href="https://stackoverflow.com/questions/22648627/how-does-auto-boxing-unboxing-work-in-java#answer-55972678" class="external" target="_blank">answer from stackoverflow</a> is by far one of the best
                    explanations I have
                    seen:</p>
                <p>So basically what the answer says is that you can use the command <span class="formula">javac
                        -XD-printflat</span> on a .java file
                    which will output another .java file with the syntactic sugar removed (including autoboxing &amp;
                    unboxing). So the answer provides us with a small programme as the following:</p>
                <code class="preformat">
                    import java.util.*;<br />
                    <br />
                    public class Boxing{<br />
                    &nbsp;public static void main(String[] args){<br />
                    &nbsp;&nbsp;Double d1 = 10.123;<br />
                    &nbsp;&nbsp;Float f1 = 12.12f;<br />
                    &nbsp;&nbsp;Long l1 = 1234L;<br />
                    &nbsp;&nbsp;Integer i1 = 55555;<br />
                    &nbsp;&nbsp;Short s1 = 2345;<br />
                    &nbsp;&nbsp;Byte b1 = 89;<br />
                    <br />
                    &nbsp;&nbsp;double d2 = d1;<br />
                    &nbsp;&nbsp;float f2 = f1;<br />
                    &nbsp;&nbsp;long l2 = l1;<br />
                    &nbsp;&nbsp;int i2 = i1;<br />
                    &nbsp;&nbsp;short s2 = s1;<br />
                    &nbsp;&nbsp;byte b2 = b1;<br />
                    &nbsp;}<br />
                    }
                </code>
                <p>Then, using the command <span class="formula">javac -XD-printflat Boxing.java</span> (assuming we are
                    in the same directory as the file Boxing.java) will output a .java file with content as below:</p>
                <code class="preformat">
                    import java.util.*;<br />
                    <br />
                    public class Boxing {<br />
                    <br />
                    &nbsp;public Boxing() {<br />
                    &nbsp;&nbsp;super();<br />
                    &nbsp;}<br />
                    <br />
                    &nbsp;public static void main(String[] args) {<br />
                    &nbsp;&nbsp;Double d1 = <span class="emphasis">Double.valueOf</span>(10.123);<br />
                    &nbsp;&nbsp;Float f1 = <span class="emphasis">Float.valueOf</span>(12.12F);<br />
                    &nbsp;&nbsp;Long l1 = <span class="emphasis">Long.valueOf</span>(1234L);<br />
                    &nbsp;&nbsp;Integer i1 = <span class="emphasis">Integer.valueOf</span>(55555);<br />
                    &nbsp;&nbsp;Short s1 = <span class="emphasis">Short.valueOf</span>(2345);<br />
                    &nbsp;&nbsp;Byte b1 = <span class="emphasis">Byte.valueOf</span>(89);<br />
                    <br />
                    &nbsp;&nbsp;double d2 = d1<span class="emphasis">.doubleValue()</span>;<br />
                    &nbsp;&nbsp;float f2 = f1<span class="emphasis">.floatValue()</span>;<br />
                    &nbsp;&nbsp;long l2 = l1<span class="emphasis">.longValue()</span>;<br />
                    &nbsp;&nbsp;int i2 = i1<span class="emphasis">.intValue()</span>;<br />
                    &nbsp;&nbsp;short s2 = s1<span class="emphasis">.shortValue()</span>;<br />
                    &nbsp;&nbsp;byte b2 = b1<span class="emphasis">.byteValue()</span>;<br />
                    &nbsp;}<br />
                    }
                </code>
                <p>As seen in the above, auto-boxing and auto-unboxing are simply convenient things (the <span class="emphasis">red addition</span> above) that the Java compiler does for us so that we don't
                    have to worry about changing a primitive data type to its corresponding wrapper class or vice versa
                    explicitly.</p>
            </section>
            <section class="topic__section">
                <h2 class="topic__section__title" id="item-4">4. understand type promotion and casting</h2>
                <h3 class="topic__section__subtitle">What is type promotion?</h3>
                <p>I personally don't like the term <span class="specialName">type promotion</span>. I like to use the
                    term <span class="specialName">type conversion</span> instead. When it comes to type conversion,
                    there are two kinds:</p>
                <ul class="list">
                    <li>widening conversion (i.e. type promotion)</li>
                    <li>narrowing conversion</li>
                </ul>
                <p>When it comes to these two kinds of type conversions, we need to bear in mind the fact that widening
                    in Java is done automatically under the hood (similar to auto-boxing and auto-unboxing), but
                    narrowing is not.</p>
                <h4 class="topic__section__subtitle--small">Widening conversion (type promotion)</h4>
                <p>So what does it do exactly? Below is a list of widening that can automatically be performed by the
                    Java compiler for you:</p>
                <ul class="list">
                    <li>byte to short, int, long, float, or double</li>
                    <li>short to int, long, float, or double</li>
                    <li>char to int, long, float, or double</li>
                    <li>int to long, float, or double</li>
                    <li>long to float or double</li>
                    <li>float to double</li>
                </ul>
                <p>The above list contains only primitives, so you may now ask what about the wrapper classes, and
                    perhaps objects too in general?</p>
                <p>In the case of wrapper classes and objects in Java, widening is done by the compiler for you.
                    However, the way widening works for objects (what we will also call
                    <span class="keyword">reference type</span>) has a
                    different mechanism. Basically, if a reference type is a <span class="keyword">subtype</span> of
                    another, then widening is the process of
                    transforming from the subtype to the <span class="keyword">supertype</span>.
                </p>
                <p>Let's see some code in action next:</p>
                <code class="preformat">
                    public TypeWidening {<br />
                    &nbsp;byte b1 = 1;<br />
                    &nbsp;short s1 = 1;<br />
                    &nbsp;char c1 = 'a';<br />
                    &nbsp;long l1 = 1L;<br />
                    <br />
                    &nbsp;public static main (String []) {<br />
                    &nbsp;&nbsp;int i1 = b1; <span class="comment">// fine, widening will be done by Java</span><br />
                    &nbsp;&nbsp;int i2 = s1; <span class="comment">// same</span><br />
                    &nbsp;&nbsp;double d1 = c1; <span class="comment">// same</span><br />
                    &nbsp;&nbsp;float f1 = l1; <span class="comment">// same</span><br />
                    &nbsp;}<br />
                    }<br />
                </code>
                <p>Bear in mind that reference types work differently, so the below will not compile:</p>
                <code class="preformat">
                    public WrongWidening {<br />
                    &nbsp;Integer integer1 = 1;<br />
                    <br />
                    &nbsp;public static main (String[]) {<br />
                    &nbsp;&nbsp;<span class="emphasis">Long long1 = integer1;</span> <span class="comment">// DNC, type Integer is not a subtype of Long</span><br />
                    &nbsp;}<br />
                    }<br />
                </code>
                <p>There's a point worth noticing in the above: note how char will not widen to short or the other round
                    (although they have the same size in bits), and byte will not widen to char (despite byte being
                    smaller than char), right? On top of that, why long can be promoted to float when long uses more
                    bits (64) than float (32)?</p>
                <p>If we go back to the primitive type table above, we can see that char is <span class="emphasis">unsigned</span>, meaning that it does not allow negative values, whereas both
                    byte and short are signed. That's why byte will not be promoted to char, nor will short. These data
                    types have incompatible ranges that it makes sense not to allow automatic conversion between them.
                </p>
                <p>As for why long can be promoted to float despite the fact that long is clearly larger in size, the
                    answer is that long actually has a smaller range than float (as shown in the table above). The
                    reason is that float may lose some precision as the number gets larger, but in return it gets a
                    larger range to operate in.</p>
                <h4 class="topic__section__subtitle--small">Narrowing conversion</h4>
                <p>As the names tell, narrowing is the opposite of widening. For example, if going from int to long is a
                    widening conversion, then the opposite &#8212; going from long to int &#8212; is a narrowing
                    conversion. In the case of a narrowing conversion, the Java compiler will not permit it unless an
                    explicit <span class="keyword">cast</span> is given.</p>
                <p>Here, an explicit cast means you need to tell the Java compiler that you really mean to narrow down
                    the data type (by specifying the data type to narrow down to) so that Java knows that it is not a
                    mistake and will permit it to happen.</p>
                <p>But why? Why is narrowing more restricted than widening in Java? As we can see in the above table,
                    whenever we are doing widening, the source value is actually preserved because the "bigger"/"upper"
                    type is in actuality bigger than the "smaller"/"lower" type. That's why Java assumes that as a safe
                    move to take which it will carry out happily for you.</p>
                <p>However, in the case of narrowing, the original value is not guaranteed to be preserved. What happens
                    if you have an int value 10_0000_0000 which is within the range of int and now you want to downcast
                    it to a short value. In that case, the value is outside the range of short, so the original value
                    will definitely not be preserved shall the conversion takes place. Thus, Java assumes such a move to
                    be "not safe" by default, and will not carry it out for you unless you state explicitly.</p>
                <p>Now, let's see how we can force Java to do a narrowing conversion for us with an explicit cast:</p>
                <code class="preformat">
                    public TypeNarrowing {<br />
                    &nbsp;int i1 = 10_0000_0000;<br />
                    <br />
                    &nbsp;public static main (String[]) {<br />
                    &nbsp;&nbsp;short s1 = (short) i1; <span class="comment">// the parentheses plus the type name inside: (short) is required to be in front of the variable to be downcast</span><br />
                    &nbsp;}<br />
                    }<br />
                </code>
                <p>So an explicit cast is done just like that: <span class="formula">(&lt;type&gt;)
                        &lt;variable_name&gt;</span>. In fact, in the case of widening, we can also use an explicit
                    cast, but such is unnecessary as it is done automatically by the Java compiler.</p>
                <p>When it comes to reference types, the idea is the same. However, make sure when you downcast S to T,
                    you know that T is a subtype of S. As an example:</p>
                <code class="preformat">
                    public ReferenceTypeNarrowing {<br />
                    &nbsp;Object obj1 = "I am actually a string";<br />
                    <br />
                    &nbsp;public static main (String[]) {<br />
                    &nbsp;&nbsp;String str1 = (String) obj1; <span class="comment">// Okay, as obj1 is really a String value</span><br />
                    &nbsp;}<br />
                    }<br />
                </code>
            </section>
            <section class="topic__section">
                <h2 class="topic__section__title" id="item-5">5. learn about operators and their precedence</h2>
                <p>Now let's learn about some common operators of the primitive data types. In the above, we have
                    already briefly talked about the numeric operators: <span class="specialName">+, -, *, /, %</span>.
                    What else are there?</p>
                <p>We have been using one which we may have taken for granted: the equal sign <span class="emphasis">=</span> which is used for assignment:</p>
                <code class="preformat">
                int i1 = 1 + 1 * 1 / 1 % 1; <span class="comment">// i1
                            will be 2</span>
                </code>
                <p>In the above, we can observe how the <span class="emphasis">operator precedence</span> plays out as what we have learnt from
                    our arithmetics classes: while we read from left to right, we would do the calculation first before
                    we go back to the assignment operator (=), and we will carry out *, /, % before we do + or -.</p>
                <p>So with all this knowledge, we should be ready to look at the table of operators below: (a modified
                    version from <a href="http://www.cs.bilkent.edu.tr/~guvenir/courses/CS101/op_precedence.html" class="external" target="_blank">Bilkent University</a>)</p>
                <table class="table">
                    <tr class="table__row">
                        <th>Precedence</th>
                        <th>Operator</th>
                        <th>Type</th>
                        <th>Associativity</th>
                    </tr>
                    <tr class="table__row">
                        <td>15</td>
                        <td>()<br>[]<br>Â·</td>
                        <td>Parentheses<br>Array subscript<br>Member selection<br></td>
                        <td>Left to Right</p>
                        </td>
                    </tr>
                    <tr class="table__row">
                        <td>14</td>
                        <td>++<br>--</td>
                        <td>Unary post-increment<br>Unary post-decrement</td>
                        <td>Right to left</td>
                    </tr>
                    <tr class="table__row">
                        <td>13</td>
                        <td>++<br>--<br>+<br>-<br>!<br>~<br>( <i>type</i> )</td>
                        <td>Unary pre-increment<br>Unary pre-decrement<br>Unary plus<br>Unary minus<br>Unary logical
                            negation<br>Unary bitwise complement<br>Unary type cast</td>
                        <td>Right to left</td>
                    </tr>
                    <tr class="table__row">
                        <td>12</td>
                        <td> * <br> / <br> % </td>
                        <td>Multiplication<br>Division<br>Modulus</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>11</td>
                        <td>+<br>-<o:p>
                        </td>
                        <td>Addition<br>Subtraction</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>10</td>
                        <td>&lt;&lt;<br>&gt;&gt;<br>&gt;&gt;&gt;</td>
                        <td>Bitwise left shift<br>Bitwise right shift with sign extension<br>Bitwise right shift with
                            zero extension</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>9</td>
                        <td>&lt;<br>&lt;=<br>&gt;<br>&gt;=<br>instanceof</td>
                        <td>Relational less than<br>Relational less than or equal<br>Relational greater
                            than<br>Relational greater than or equal<br>Type comparison (objects only)</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>8</td>
                        <td>==<br>!=</td>
                        <td>Relational is equal to<br>Relational is not equal to</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>7</td>
                        <td>&amp;</td>
                        <td>Bitwise AND</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>6</td>
                        <td>^</td>
                        <td>Bitwise exclusive OR</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>5</td>
                        <td>|</td>
                        <td>Bitwise inclusive OR</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>4</td>
                        <td>&amp;&amp;</td>
                        <td>Logical AND</p>
                        </td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>3</td>
                        <td>||</td>
                        <td>Logical OR</td>
                        <td>Left to right</td>
                    </tr>
                    <tr class="table__row">
                        <td>2</td>
                        <td>? :</td>
                        <td>Ternary conditional</td>
                        <td>Right to left</td>
                    </tr>
                    <tr class="table__row">
                        <td>1</td>
                        <td>=<br>+=<br>-=<br>*=<br>/=<br>%=</td>
                        <td>Assignment<br>Addition assignment<br>Subtraction assignment<br>Multiplication
                            assignment<br>Division assignment<br>Modulus assignment</td>
                        <td>Right to left</td>
                    </tr>
                </table>
                <p>Note that <span class="emphasis">precedence 15</span> in the table is of the highest precedence and
                    will always be first to carry out in a statement, whereas <span class="emphasis">precedence 1</span>
                    is the lowest and will be carried out at last.</p>
                <h4 class="topic__section__subtitle--small">Precedence 15</h4>
                <p>Let's kick off with <span class="specialName emphasis">()</span>, <span class="specialName emphasis">[]</span> &amp; <span class="specialName emphasis">.</span> in row <span class="emphasis">precedence 15</span>. () states
                    that what is inside the parentheses should be executed first. For example:</p>
                <code class="preformat">int i1 = (1 + 3) * 5 <span class="comment">// will be 20 because 1 + 3 will be executed before * 5</span></code>
                <p>As for [] (square brackets), they are used for declaration of arrays and for selection of array
                    elements. We will talk more about arrays in a later topic: <a href="ch5.html" class="nav__link">Topic 5: Arrays &amp; Collections</a>. For now, let's look at a couple
                    examples below:</p>
                <code class="preformat">int[] intArray = new int[5]; <span class="comment">// declare an int array called intArray and assign it to an int array with 5 elements to allocate in memory</span></code>
                <p>The above can actually be divided into two separate steps:</p>
                <code class="preformat">int [] intArray; <span class="comment">// declare an int array called intArray</span><br />
                    intArray = new int[5]; <span class="comment">// now assign the variable to an int array with 5 elements</span></code>
                <p>We can also then assign an int value to the first element inside the int array as follows:</p>
                <code class="preformat">intArray[0] = 1; <span class="comment">// select index 0 of intArray (i.e. the first element in intArray) and assign it to 1</span></code>
                <p>We will talk about <span class="emphasis">indexing</span> in Java in details later. For now, (just
                    like any other programming languages) index always starts at 0 in Java. That's why index 0 refers to
                    the first element, and index 1 refers to the second element, etc.</p>
                <p>Finally, we have actually seen and used the member selection operator . (dot) a few times so far. For example:</p>
                <code class="preformat">Integer integer1 = Integer<span class="emphasis">.</span>valueOf(123);</code>
                <p>In the above, we use . to select the member <span class="specialName">valueOf</span> (which is a method here) of
                    the Integer class.</p>
                <p>Let's look at another example below:</p>
                <code class="preformat">System.out.println(Math<span class="emphasis">.</span>PI); <span class="comment">// this will print out 3.141592653589793</span></code>
                <p>This time, we use <span class="specialName">.</span> to select the member <span class="specialName">PI</span> (which is a variable) of the Math class and print it out to the
                    console via <span class="specialName">System.out.println()</span>.</p>
                <h3 class="topic__section__subtitle">Unary operators in depth</h3>
                <h4 class="topic__section__subtitle--small">Precedence 14 &amp; Precedence 13</h4>
                <p>Note that the two rows <span class="emphasis">precedence 14 &amp; 13</span> are composed of <span class="specialName">unary operators</span>: they are operators that work with one and only one
                    variable or value.</p>
                <p>We can see <span class="specialName">++</span> &amp; <span class="specialName">--</span> in both rows
                    <span class="emphasis">precedence 14 &amp; 13</span>. In row <span class="emphasis">precedence
                        14</span>, they are <span class="emphasis">post</span>-increment and decrement respectively,
                    whereas in <span class="emphasis">precedence 13</span>, they are <span class="emphasis">pre</span>-increment &amp; decrement. So, what are their differences?
                </p>
                <p>As can be told from their names, the post-operators in row <span class="emphasis">precedence
                        14</span> are placed after a numeric variable, whereas the pre-operators in <span class="emphasis">precendence 13</span> are placed in front:</p>
                <code class="preformat">
                    int i1 = 0;<br />
                    int i2 = 0;<br />
                    System.out.println(i1++); <span class="comment">// this is a post-increment: it prints out 0, and then increments i1 by 1, so after the printing i1 becomes 1</span><br />
                    System.out.prinlnt(++i2); <span class="comment">// this is a pre-increment: it increments i2 by 1 first, and then prints out the current i2 value, which is 1</span><br />
                </code>
                <p>For the exam, please do understand the above and the differences between a post-increment(decrement)
                    and pre-increment(decrement). In short, a <span class="emphasis">post</span> operator will delay the
                    increment or decrement until the statement completes, whereas a <span class="emphasis">pre</span>
                    operator will immediately do the increment/decrement before the rest of statement continues to be
                    evaluated. </p>
                <p>Next, let's look at the logical negation <span class="specialName">!</span>. It is a simple operator
                    that negates a boolean value (i.e. true / false):</p>
                <code class="preformat">
                    boolean b1 = !true; <span class="comment">// !true is false; b1 is assigned to false</span><br />
                    Boolean b2 = !b1; <span class="comment">// !b1 is simply !false, which is true; b2 is then assigned to true</span><br />
                    System.out.println(!b2); <span class="comment">// prints out false</span><br />
                </code>
                <p>For the unary operators <span class="specialName">+ &amp; -</span>, while the former is not usually
                    used, the latter is as it can indicate a negative value:</p>
                <code class="preformat">
                    double d1 = <span class="emphasis">-</span>1.0;<br />
                    long l1 = <span class="emphasis">+</span>1; <span class="comment">// +1 is just 1</span><br />
                </code>
                <p>Now it comes the bitwise operator <span class="specialName">~</span>. This one is used for
                    manipulating individual bits. Specifically, it turns the '1' bits to '0', and the '0' bits to '1'.
                    Please note that this operator is based on <a href="https://en.wikipedia.org/wiki/Two%27s_complement" class="external">two's complement</a>
                    used in binary arithmetics. In short, <span class="emphasis">an integer N will become -(N+1)</span>
                    after the bitwise complement conversion. Let's have a look at the below example:</p>
                <code class="preformat">
                    int i1 = 17; <span class="comment">// 17 in <span class="emphasis">binary </span>is 0001 0001</span><br />
                    int i2 = ~i1; <span class="comment">// the one's complement of 0001 0001 is 1110 1110, which is equal to the two's complement of -18, so i2 is assigned to -18</span><br />
                </code>
                <p>Last but not least, we have already seen the type cast opeartor above when we were discussing type
                    conversion. Now, let's revise its usage with an example below:</p>
                <code class="preformat">
                    char c1 = 'a';<br />
                    byte b1 = (byte) (short) c1; <span class="comment">// since unary opeartors work from right to left, we first cast c1 to short, and then cast the short value to byte</span><br />
                    byte b2 = (byte) c1; <span class="comment">// it could work directly like this as well</span><br />
                </code>
                <h3 class="topic__section__subtitle">Binary operators in depth</h3>
                <p>Note that the rest of table (except row <span class="emphasis">precedence 2</span>) is composed of
                    <span class="specialName">binary operators</span>: they are operators that work with two
                    variables/values
                </p>
                <h4 class="topic__section__subtitle--small">Precedence 12 to Precedence 10: Numeric operations</h4>
                <p>From rows precedence 12 to 10, all the operators are for numeric operations. In particular, we will
                    just focus on the bitwise operators in precedence 10 below because the others are assumed to be
                    well-understood already.</p>
                <p>First, let's talk about <span class="specialName">&lt;&lt;</span>, which is called the bitwise left
                    shift operator. If we shift a number to the left by 1, all the bits in it will be pushed to the left
                    by 1 position, which will result in a missing last position. The missing last position will then be
                    filled with the bit '0'.</p>
                <p>This may sound confusing now. So let's take a look at what it actually does with a quick example:</p>
                <code class="preformat">
                    int i1 = 10; <span class="comment">// 10 in binary is 0000 1010</span><br />
                    int i2 = i1&lt;&lt;1; <span class="comment">// pushed to the left by 1, so we will have 0001 010_, where _ is the missing last position to be filled with '0', so we'll have 0001 0100, which is 20 in decimal</span>
                </code>
                <p>Here's an animation of what happened in the code above:</p>
                <div class="gsap_ani gsap_ani--1">
                    <button class="gsap_play" id="tl_1_player">play</button>
                    <div id="ani--1_1">0</div>
                    <div id="ani--1_2">0001010</div>
                    <div id="ani--1_3">0</div>
                </div>
                <p>Next, let's talk about <span class="specialName">&gt;&gt;</span>, which is known as the <span class="emphasis">signed</span> bitwise right shift.
                    Since it is "signed", this operator will use the left most bit to fill in the trailing positions
                    after right shift. As a side note, Java uses <span class="specialName">two's complement</span> to
                    represent negative integers in binary. Therefore, the integer -10 is 1111111111110110 in Java
                    binary. With that piece of information, we can now look at an example below:</p>
                <code class="preformat">
                    int i1 = -10; <span class="comment">// 1111111111110110</span><br />
                    int i2 = i1&gt;&gt;2; <span class="comment">// pushed to the right by 2, so we will have _ _11111111111101, where _ _ are two missing trailing positions to be filled with the originial leftmost bit, which was '1', so we'll have 1111111111111101, which is -3 in decimal</span>
                </code>
                <p>Here's an animation of the above signed right-shift example:</p>
                <div class="gsap_ani gsap_ani--2">
                    <button class="gsap_play" id="tl_2_player">play</button>
                    <div id="ani--2_3">11</div>
                    <div id="ani--2_2">11111111111101</div>
                    <div id="ani--2_1">10</div>
                </div>
                <p>Finally, <span class="specialName">&gt;&gt;&gt;</span> which is called <span class="emphasis">unsigned</span> bitwise right shift, will always use '0' to fill in the trailing
                    positions after right shift. As an example:</p>
                <code class="preformat">
                    int i1 = -10; <span class="comment">// 1111111111110110</span><br />
                    int i2 = i1&gt;&gt;&gt;2; <span class="comment">// pushed to the right by 2, so we will have _ _11111111111101, where _ _ are two missing trailing positions to be filled with '0', so it will be 0011111111111101, which is 1073741821</span>
                </code>
                <p>If the above <span class="emphasis">unsigned</span> bitwise right shift is a bit confusing, that's
                    entirely normal. The thing about these bitwise right shift operators is, in effect they actually
                    divide a given number (the left operand) by the 2 to the power of the right operand. This may be
                    useful in a situation like this: <span class="formula">int mid_to_calc = (small + big) / 2</span>.
                </p>
                <p>Instead of doing the above, we can do this: <span class="formula">int mid_to_calc = (small + big) >>>
                        1</span>, given that both small and big are positive integers here.</p>
                <p>If you are interested in more details on this topic, I suggest that you refer to <a href="https://stackoverflow.com/questions/19058859/what-does-mean-in-java/19058871" class="external" target="_blank">this stackoverflow post</a> which I personally find very
                    helpful.</p>
                <h4 class="topic__section__subtitle--small">Precedence 9 to Precedence 8: Relational operations</h4>
                <p>In the rows of precedence 9 and precedence 8, we can see six <span class="keyword">relational operators</span>. There's also the <span class="specialName">instanceof</span> operator, which
                    we will talk about at the end of this section. Right now, let's dive into the six relational
                    operators first.</p>
                <p>They are <span class="specialName">==</span> (is equal to), <span class="specialName">!=</span> (is
                    not equal to), <span class="specialName">&gt;</span> (greater than), <span class="specialName">&lt;</span> (less than), <span class="specialName">&gt;=</span> (greater
                    than or equal to), and <span class="specialName">&lt;=</span> (less than or equal to).</p>
                <p>The output of these relational operators is a boolena value (either true or false). Below shows an
                    example.</p>
                <code class="preformat">
                    int i1 = 1;<br />
                    int i2 = 2; <span class="comment">// or simply write "int i1 = 1, i2 = 2";</span><br />
                    System.out.println(i1 == i2); <span class="comment">false as 1 is not equal to 2</span><br />
                    System.out.println(i1 != i2); <span class="comment">true as 1 is not equal to 2</span><br />
                    System.out.println(i1 &lt; i2); <span class="comment">true as 1 is less than 2</span><br />
                    System.out.println(i1 &gt; i2); <span class="comment">false as 1 is not greater than 2</span><br />
                    System.out.println(i1 &lt;= i2); <span class="comment">true as 1 is less than or equal to 2</span><br />
                    System.out.println(i1 &gt;= i2); <span class="comment">false as 1 is not greater than or equal to 2</span>
                </code>
                <p>There's one thing we need to pay attention to when we're using relational operators with primitive
                    types, which is that they can all be compared across all types:</p>
                <code class="preformat">
                    float f1 = 2; char c1 = '\001'; short s1 = 0; <span class="comment">f1 is 2.0, c1 is '\001' (i.e. 1) and s1 is 0. Note the use of ; instead of ,</span><br />
                    System.out.println(f1 > c1); <span class="comment">// true</span><br />
                    System.out.println(c1 = s1); <span class="comment">// true</span>
                </code>
                <p>When it comes to reference types, things get quite tricky pretty fast as we need to consider different things. First, recall that a reference type is just a means to access the object it references stored in memory.
                    Now when we use the <span class="specialName">==</span> operator on reference types, we are <span class="emphasis">NOT</span> testing whether they have the same values anymore, but we're testing if the reference types actually <span class="emphasis">refer to the same object in the memory</span>.
                </p>
                <p>So here's the deal: if I create two instances (a.k.a. objects) of the Integer class (or some other classes), regardless of whether they have the same value, the two reference types that point to the two instances are not equal under the <span class="specialName">==</span> test.</p>
                <p>That said, when you're ready to create two Integer instances that have the same value and expect them to be not equal, there's a caveat. That caveat comes from a concept called <span class="keyword">Integer caching</span> in Java. For example:</p>
                <code class="preformat">
                    Integer a = 1; <span class="comment">// autoboxing values between -128 &amp; 127, caching takes place</span><br />
                    Integer b = 1; <span class="comment">// again, pointing to the created instance above as it has the same value</span><br />
                    Integer c = new Integer(1); <span class="comment">// using the keyword new forces Java to create a new Integer instance!</span><br />
                    System.out.println(a == b); <span class="comment">// true due to caching</span><br />
                    System.out.println(a == c); <span class="comment">// false, as c is a new Integer object</span><br />
<br />

                </code>
                <p>Caching also applies to other non-floating wrapper classes like Long, Char and Short as demonstrated below.</p>
                <code class="preformat">
                    Short.valueOf((short) 5) == Short.valueOf((short) 5); <span class="comment">// true as caching takes place in range [-127, 128]</span><br />
                    Character.valueOf('\001') == Character.valueOf('\001'); <span class="comment">// true again</span><br />
                    Long.valueOf(130) == Long.valueOf(130); <span class="comment">// false this time as caching does not work when out of range [-127, 128]</span>
                </code>
                <p>When it comes to comparing values with <span class="specialName">&lt;, &gt;, &lt;= &amp; &gt;=</span>, they are more straightforward.
                    You need to know that they work across all types of wrapper classes, which means you can compare a Double value and a Short value without encountering an issue. For instance:</p>
                <code class="preformat">
                    Short s1 = (short) 5;<br />
                    Double d1 = 5.1;<br />
                    System.out.println(d1 > s1); <span class="comment">// true</span>
                </code>
                <p>Finally, let's talk about the <span class="specialName">instanceof</span> operator. It only works for objects because it tests if an object belongs to (is an instance of) a particular class.</p>
                <p>For example, if we create an Integer value <span class="specialName">int1</span>, then <span class="formula">int1 instanceof Integer</span> will return <span class="emphasis">true</span>. Since all objects in Java ultimately inherit from the <span class="specialName">Object</span> class, <span class="formula">int1 instanceof Object</span> will also return true.</p>
                <p>How about <span class="formula">int1 instanceof Double</span>? Yes, it will return <span class="emphasis">false</span> since the Integer class is not a subtype of the Double class. We will dive into objects and the concepts behind OOP (object-oriented programming) in Java in topic 3: <a href="./ch3.html" class="nav__link">Object-oriented Programming Concepts</a>.</p>
                <h4 class="topic__section__subtitle--small">Precedence 7 to Precedence 3: Bitwise &amp; Logical operations</h4>
                <p>Similar to relational operators, logical operators return a boolean value (either true or false), but instead of performing comparison between values, logical operators take two boolean values and apply <span class="emphasis">AND/OR</span> to them to evaulate the final boolean value.</p>
                <p>Notice that in rows precedence 7 to precendence 5, <span class="specialName">&, ^, |</span> are the bitwise operators of "AND/OR". Before we talk about them though, we will first look at the logical counterparts: <span class="specialName">&& and ||</span>.</p>
                <p>As these two operators take two boolean expressions as their operands, we can summarize their behaviour into the below table:</p>
                <table class="table">
                    <thead>
                        <tr class="table__row">
                            <th></th>
                            <th>1st: true, 2nd: true</th>
                            <th>1st: false, 2nd: false</th>
                            <th>1st: true, 2nd: false (or reverse)</th>
                        </tr>
                        <tr class="table__row">
                            <th>&&</th>
                            <td>true && true is true</td>
                            <td>false && false is false</td>
                            <td>true && false is false</td>
                        </tr>
                        <tr class="table__row">
                            <th>||</th>
                            <td>true || true is true</td>
                            <td>false || false is false</td>
                            <td>true || false is true</td>
                        </tr>
                    </thead>
                </table>
                <p>Pay attention to the fact that <span class="specialName">&&</span> is of higher precedence than <span class="specialName">||</span>, meaning that if we are to put them together like the below, && will be evaluated first before ||:</p>
                <code class="preformat">
                    true || true && false <span class="comment">// this will evaluate to <span class="specialName">true</span></span>
                </code>
                <p>Here's an animation of the above code in case it's still not clear to you as to how it works.</p>
                <div class="gsap_ani gsap_ani--3">
                    <button class="gsap_play" id="tl_3_player">play</button>
                    <div id="ani--3_5">true</div>
                    <div id="ani--3_4">||</div>
                    <div id="ani--3_3">true</div>
                    <div id="ani--3_2">&&</div>
                    <div id="ani--3_1">false</div>
                </div>
                <p>When it comes to the bitwise logical operators, they work similarly to the logical operators above when taking two boolean values as their operands. However, there's one significant distinction that we need to bear in mind.</p>
                <p>That is, the logical operators above (i.e. && and ||) are <span class="keyword">short-circuit</span>, whereas the bitwise counterparts (i.e. &, ^ and |) are not.</p>
                <p>With that, we can now take a look at the below table which summarizes the bitwise logical operators when they take boolean values as their operands:</p>
                <table class="table">
                    <thead>
                        <tr class="table__row">
                            <th></th>
                            <th>1st: true, 2nd: true</th>
                            <th>1st: false, 2nd: false</th>
                            <th>1st: true, 2nd: false (or reverse)</th>
                        </tr>
                        <tr class="table__row">
                            <th>&</th>
                            <td>true & true is true</td>
                            <td>false & false is false</td>
                            <td>true & false is false</td>
                        </tr>
                        <tr class="table__row">
                            <th>^</th>
                            <td>true ^ true is false</td>
                            <td>false ^ false is false</td>
                            <td>true ^ false is true</td>
                        </tr>
                        <tr class="table__row">
                            <th>|</th>
                            <td>true | true is true</td>
                            <td>false | false is false</td>
                            <td>true | false is true</td>
                        </tr>
                    </thead>
                </table>
                <p>Besides taking boolean values as their operands, the bitwise logical operators also take numeric values. If you are interested in this topic, here's a link to a <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators" class="external" target="_blank">Wikipedia page</a> which summarizes how bitwise operators work with binary numbers.</p>
                <h4 class="topic__section__subtitle--small">Precedence 2: Tertiary conditional operations</h4>
                <p>As the word "tertiary" implies, this operator takes 3 operands: <span class="formula">1st <span class="emphasis">?</span> 2nd <span class="emphasis">:</span> 3rd</span>. The first operand is a boolean expression of which the outcome will determine whether the second or the third operand will be returned.</p>
                <p>If the first operand evaluates to true, the second operand will be returned and the third operand will be ignored. Conversely, if the first operand evaluates to false, then the third operand will be returned and the second operand ignored.</p>
                <p>Let's have a look at a somewhat complicated example now to make sure we know how this operator works:</p>
                <code class="preformat">
                    int a = 5, b = 4;<br />
                    int c = (b++ == a) ? ++a : ++b; <span class="comment">// b++ == a is false as b++ (post-increment) will return the current value of b to the boolean expression (the increment only takes place after the evaluation completes), and so after it is evaluated to false, b becomes 5, and the third operand, ++b, will be returned, so c will be 6</span>
                </code>
                <p>Make sure you are aware that a is still 5 at the end because the second operand (++a) was never executed in the tertiary operator above.</p>
                <h4 class="topic__section__subtitle--small">Precedence 1: Assignment operations</h4>
                <p>The last row (of the lowest precedence) is pretty straightforward. They are assignment operators which mean they assign a value to a variable (the first operand). In fact, we have been using the assignment operator <span class="specialName">=</span> since the beginning which simply assigns the second operand to the first. However, be careful to not confuse it with the relational operator <span class="specialName">==</span> as they are completely different in nature.</p>
                <p>Other than <span class="specialName">=</span>, we also have <span class="specialName">+=</span>, <span class="specialName">-=</span>, <span class="specialName">*=</span>, <span class="specialName">/=</span> &amp; <span class="specialName">%=</span> which simply mean the first operand will <span class="specialName">+</span>/<span class="specialName">-</span>/<span class="specialName">*</span>/<span class="specialName">/</span>/<span class="specialName">%</span> the second operand and then assign the result to the first operand.</p>
                <p>Let's now look at some examples below:</p>
                <code class="preformat">
                    int a = 5, b = 4;<br />
                    a += b; <span class="comment">// i.e. a = a + b, so a = 5 + 4, a = 9</span><br />
                    a -= b; <span class="comment">// i.e. a = a - b, so a = 9 - 4, a = 5</span><br />
                    a *= b; <span class="comment">// i.e. a = a * b, so a = 5 * 4, a = 20</span><br />
                    a /= b; <span class="comment">// i.e. a = a / b, so a = 20 / 4, a = 5</span><br />
                    a %= b; <span class="comment">// i.e. a = a % b, so a = 5 % 4, a = 1</span>
                </code>
                <p>There is one subtle yet significant difference between writing <span class="formula">a += b</span> and <span class="formula">a = a + b</span> though. Let's say <span class="specialName">a</span> is byte instead of int, and <span class="specialName">b</span> is now a double. Clearly <span class="formula">a = a + b</span> wouldn't work then, nor would <span class="formula">a = a - b</span>, etc. That is because when we evaluate <span class="formula">a + b</span>, the evaluated outcome would be of type <span class="emphasis">double</span>, so we cannot really assign it to <span class="specialName">a</span>, which is of type <span class="emphasis">byte</span>.</p>
                <p>However, in that case, <span class="formula">a += b</span> would actually still work, as would <span class="formula">a -= b</span> and others. That's because before the assignment takes place, Java will actually cast the evaulated outcome back to the type of the first operand (which is <span class="specialName">a</span> here), to make our lives a little easier.</p>

            </section>
            <section class="topic__section">
                <h2 class="topic__section__title" id="item-6">6. learn about var (local variable type inference) &amp; lambda parameters</h2>
                <h3 class="topic__section__subtitle">What is var (local variable type inference)?</h3>
                <p>In short, <span class="specialName">var</span> is to let the Java compiler guess the data type for you so you don't have to write the type of a variable explicitly. Let's look at a couple of examples first:</p>
                <code class="preformat">
                    public class VarTest {<br />
                        &nbsp;public static main (String[]) {<br />
                    &nbsp;&nbsp;var iAmAnInt = 100; <span class="comment">// Java recognizes from 100 that the variable will be an int</span><br />
                    &nbsp;&nbsp;var iAmADouble = 1.01; <span class="comment">// Java recognizes from 1.01 that the variable will be a double</span><br />
                    &nbsp;&nbsp;var iAmAFloat = 1.01f; <span class="comment">// Java recognizes from 1.01f that the variable will be a float</span><br />
                    &nbsp;&nbsp;var iAmAString = "hello!"; <span class="comment">// Java recognizes from "hello!" that the variable will be a String</span><br />
                        &nbsp;}<br />
                    }
                </code>
                <p>Now, there is a couple conditions to meet before you start to use <span class="specialName">var</span> everywhere in your code. First, <span class="specialName">var</span> can only work with <span class="keyword">local variables</span>. So if you use <span class="specialName">var</span> outside a method, Java will not compile the code. Second, <span class="specialName">var</span> cannot be used for compound declaration. So while <span class="formula">int a = 1, b = 2;</span> will work, <span class="formula">var a = 1, b = 3;</span> is not allowed.</p>
                <p>In general, you may want to use <span class="specialName">var</span> for less typing and in cases where the data types are obvious anyways (like the cases above). We will see more examples of <span class="specialName">var</span> and how they can help reduce unnecessary typing in subsequent topics.</p>
                <h3 class="topic__section__subtitle">A quick glimpse into lambda parameters</h3>
                <p>Lambda parameters are part of <span class="keyword">lambda expressions</span>. We will talk more about lambda expressions in topic 6: <a href="./ch6.html" class="nav__link">Streams &amp; Lambda Expressions</a>. For now, we will only focus on the basics.</p>
                <p>So a typical lambda expression looks like this: <span class="formula">(lambda parameter(s)) -> {lambda expression}</span>.</p>
                <p>A minimal example would be a lambda expression with no lambda parameters and an empty lambda expression body: <span class="formula">() -> {}</span>. Let's look at a few more examples below:</p>
                <code class="preformat">
                    <span class="comment">// () can be skipped for one parameter. {} can be skipped for one statement as the lambda expression body</span><br />
                    a -> System.out.println(a)<br />
                    <span class="comment">// () is mandatory if the type of parameter is given</span><br />
                    (int a) -> System.out.println(a)<br />
                    <span class="comment">// for multiple parameters, if one parameter is given a type, all parameters have to be given a type too</span><br />
                    <span class="emphasis">(a, String b) -> {}</span> <span class="comment">// DNC, not allowed</span><br />
                    (int a, String b) -> {}<br />
                    <span class="comment">// if <span class="specialName">var</span> is used for one parameter, all parameters have to be <span class="specialName">var</span></span>
                    <span class="emphasis">(int a, var b) -> {}</span> <span class="comment">// DNC, not allowed</span><br />
                    (var a, var b) -> {}<br />
                    <span class="comment">// finally, whenever {} is used, the statement(s) inside have to end with a semicolon ;</span><br />
                    () -> {System.out.println("hello!")<span class="emphasis">;</span>}
                </code>
            </section>

            <section class="topic__section">
                <h2 class="topic__section__title" id="item-7">Summary of Topic 1</h2>
                <p>In this topic, we have learnt about the 8 types of primitive data in Java, namely:
                    <span class="emphasis">boolean</span>, <span class="emphasis">byte</span>, <span class="emphasis">char</span>, <span class="emphasis">short</span>,
                    <span class="emphasis">int</span>, <span class="emphasis">long</span>, <span class="emphasis">float</span>, and <span class="emphasis">double</span>.
                    Not only did we learn about their sizes and values ranges, but also how we could declare variables of their types and assign values to them.
                </p>
                <p>We also learnt the Java variable naming rules. In particular, we saw from multiple examples that (1) all identifiers (i.e. variable names) must begin with a letter, $ or _;
                    (2) a single underscore is not a valid identifier; (3) numbers are allowed except in the first position of an identifier.
                </p>
                <p>After that, we jumped into the world of wrapper classes which are the "object version" of the primitive types. We saw how Java perform auto-conversion between primitive types
                    and their corresponding wrapper classes for us. In particular, the auto-conversion from a primitive type to a wrapper class object is called auto-boxing, and the reverse is called auto-unboxing.
                </p>
                <p>Besides auto-conversion, we also touched upon the topic of type conversion. We saw why in Java, widening conversion (i.e. type promotion) is implicitly accepted by the Java compiler,
                    and also why narrowing conversion is not. Specifically, we learnt that narrowing conversion (i.e. from a "bigger" type to a "smaller" type) requires an explicit cast to work.
                </p>
                <p>Then we dove into a list of opeartors. We categorized them and discussed their usages from the highest precedence to the lowest.
                    While unary operators are of the highest precedence, we see a tertiary operator which is of higher precendence than the binary operators for assignment.
                </p>
                <p>Last but not least, we learnt a little bit about var (i.e. local variable type inference) as well as some rules of specifying lambda parameters. We will see var and lambda again in the subsequent topics.</p>

            </section>
        </main>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js" integrity="sha512-cdV6j5t5o24hkSciVrb8Ki6FveC2SgwGfLE31+ZQRHAeSRxYhAQskLkq3dLm8ZcWe1N3vBOEYmmbhzf7NTtFFQ==" crossorigin="anonymous"></script>
    <script src="../javascript/nav.js"></script>
    <script src="../javascript/theme.js"></script>
    <script src="../javascript/backToTop.js"></script>
    <script src="../javascript/sizeControl.js"></script>
    <script src="../javascript/sidebar.js"></script>
    <script src="../javascript/keywords.js"></script>
    <script src="../javascript/keywordModal.js"></script>
    <script src="../javascript/commentToggle.js"></script>

    <script>
        var tl_1 = gsap.timeline({
            paused: true,
            onComplete: () => {
                Reset(tl_1)
            }
        });
        tl_1.to("#ani--1_1", {
            opacity: 0,
            duration: 1
        });
        tl_1.to("#ani--1_2", {
            x: -15,
            duration: 1
        });
        tl_1.to("#ani--1_3", {
            opacity: 1,
            duration: 1
        });
        tl_1.to("#ani--1_3", {
            x: -15,
            duration: 1
        });
        tl_1.to("#ani--1_2", {
            opacity: 0,
            duration: 5,
            delay: 2
        });
        tl_1.to("#ani--1_3", {
            opacity: 0,
            duration: 5
        }, 6);

        var tl_1_play = document.querySelector("#tl_1_player");
        tl_1_play.addEventListener('click', () => {
            tl_1.restart()
        });

        var tl_2 = gsap.timeline({
            paused: true,
            onComplete: () => {
                Reset(tl_2)
            }
        });
        tl_2.to("#ani--2_1", {
            opacity: 0,
            duration: 1
        });
        tl_2.to("#ani--2_2", {
            x: 20,
            duration: 1
        });
        tl_2.to("#ani--2_3", {
            opacity: 1,
            duration: 1
        });
        tl_2.to("#ani--2_3", {
            x: 20,
            duration: 1
        });
        tl_2.to("#ani--2_2", {
            opacity: 0,
            duration: 5,
            delay: 2
        });
        tl_2.to("#ani--2_3", {
            opacity: 0,
            duration: 5
        }, 6);

        var tl_2_play = document.querySelector("#tl_2_player");
        tl_2_play.addEventListener('click', () => {
            tl_2.restart()
        });

        var tl_3 = gsap.timeline({
            paused: true,
            onComplete: () => {
                Reset(tl_3)
            }
        });
        tl_3.to("#ani--3_1", {
            backgroundColor: "var(--highlight-color)",
            duration: 1
        })
        tl_3.to("#ani--3_2", {
            backgroundColor: "var(--highlight-color)",
            duration: 1
        }, 0)
        tl_3.to("#ani--3_3", {
            backgroundColor: "var(--highlight-color)",
            duration: 1
        }, 0)
        tl_3.to("#ani--3_1", {
            x: -65,
            duration: 1
        })
        tl_3.to("#ani--3_2", {
            opacity: 0,
            duration: 1
        }, 1)
        tl_3.to("#ani--3_3", {
            opacity: 0,
            x: 65,
            duration: 1
        }, 1)
        tl_3.to("#ani--3_4", {
            backgroundColor: "var(--highlight-color)",
            duration: 1
        })
        tl_3.to("#ani--3_5", {
            backgroundColor: "var(--highlight-color)",
            duration: 1
        }, 2)
        tl_3.to("#ani--3_1", {
            x: -120,
            duration: 1
        }, 2)
        tl_3.to("#ani--3_5", {
            x: 40,
            duration: 1
        })
        tl_3.to("#ani--3_4", {
            opacity: 0,
            duration: 1
        }, 3)
        tl_3.to("#ani--3_1", {
            x: -165,
            opacity: 0,
            duration: 1
        }, 3)
        tl_3.to("#ani--3_5", {
            opacity: 0,
            duration: 2.5,
            delay: 1
        })

        var tl_3_play = document.querySelector("#tl_3_player");
        tl_3_play.addEventListener('click', () => {
            tl_3.restart()
        });

        function Reset(tl) {
            tl.pause();
            tl.progress(0);
        }
    </script>
</body>

</html>